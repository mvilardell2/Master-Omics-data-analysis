---
title: "Final Report"
subtitle: "Preprocessing steps"
author: "Marina Vilardell"
date: "2023-08-16"
output: 

  BiocStyle::html_document:
    number_sections: true
    toc_float: yes
---

In this report you will find all the steps performed to analyze microarray data coming from healthy and cancer affected patients with BRCA1/2 mutated and no-mutated. The array used is the GeneChip Human Genome U133 Plus 2.0. 

# Working directory and libraries

Set working directory and the libraries needed to load the files:

```{r,message=FALSE,warning=FALSE}
wd<-setwd("C:/Users/MARINA/Documents/MASTER/TFM/Data_analysis")

# wd of the Cel files
cel.wd<-'../Initial_analysis/CEl_files'

library(readxl)
library(affy)
library(limma)
library(glmnet)
library(immunedeconv)
library(tidyverse)
library(ggplot2)
library(DT)
```

# Load and prepare the data

Load the file that contains the phenodata (treatment, mutation, Disease ...) and the CEL files. Then, check that the phenodata and CEL files are in the same order. 
```{r,message=FALSE,warning=FALSE}
#Load pheno data
pdata<-read.csv2('../Initial_analysis/phenodata.csv',header=TRUE)

#change the wd to where the cel files are
setwd(file.path(wd,cel.wd))

# get eligible data ("CEL" files)
celFiles = list.files(file.path(wd,cel.wd), pattern = "CEL")

# --- Pdata and cel files have to be in the same order ---
pdata$ID<-gsub(' ','_',pdata$ID)
order<-pdata$ID
factor_celfiles<-factor(celFiles,levels = order)
celFiles_ordered<-celFiles[order(factor_celfiles)]

#check the order
identical(celFiles_ordered,pdata$ID)#same order
head(cbind(celFiles_ordered, pdata))

```


## Read CEL files

Once the data is loaded, we will read the CEL files with the ReadAffy() function. 

```{r,read cel files,warning=FALSE}
# change row names of pdata
rownames(pdata)<-pdata$ID
pdata<-pdata[,-1]

# Read CEL files 
setwd(file.path(wd,cel.wd))
brca_data <- ReadAffy(filenames = as.vector(rownames(pdata)), phenoData = pdata)

brca_data
```

Brca_data is an AffyBatch Object that contains all 106 samples and 54675 probe sets.

## Data exploration 

We will explore the data to help clarify what we have now. 

```{r}
# --- matrix of intensities for each probe ---
head(exprs(brca_data))[,1:6]
dim(exprs(brca_data))
```

The matrix of intensities contains raw signal, not normalized. We have 106 samples and 1354896 probes. Now let's get information regarding the phenodata. 

The following tables will summarize the number of individuals for each condition: 
```{r}
# --- Get phenoData ---
head(pData(brca_data))

# Number of healthy and Afected samples
table(pData(brca_data)$Disease)

# Number of samples for each phenotype
table(pData(brca_data)$Phenotype)

# Number of samples non-radiated and radiated
table(pData(brca_data)$Treatment)

```


# Quality control

In the quality control step, we will check the distributions of the data to detect possible outliers and remove them from the study. 


## Image assessment

We first start checking the images that are generated by the scan. The intensities are measuring the amount of expression in each probe.

```{r}
# --- array images ----
#image(brca_data)

```
![](C:/Users/MARINA/Documents/MASTER/TFM/Initial_analysis/image_17.jpg)

The images of the scan were generated for all the 106 samples, but just the image for sample 17 is showed. The rest of the images can be found in the Supplementary section. 

In SG-18.CEL, SG-107.CEL and SG-121.CEL there are little marks, but they were not significant enough to remove the arrays.


## Data quality plots

Now we will check the quality of the data by producing some intensity density plots, intensity box plots, MAplots and RLE and NUSE box plots.

```{r}
# BOXPLOT
colors<-palette('Set2')
boxplot(brca_data,col=colors,las=3,cex.axis=0.3, main='Boxplot of intensities',ylab='Intensity level',xlab='samples') 
```

In the boxplot we see that all the samples intensity medians are quite in the same range. Obviously there are samples with higher expression and other with lower, but it is fine to see heterogeneity. No outliers are detected. The boxplots of the three samples SG-18.CEL, SG-107.CEL and SG-121.CEL seem to have a normal distribution such as other samples.


```{r}
# HISTOGRAM

hist(brca_data,col=colors, main='Histogram of intensities',ylab='Density',xlab='Log itensity')
```

This histogram shows the distribution of the intensities. Sample SG-81.CEL seems to have a little bit of more intensities than the others, but it is not considered an outlier. 

```{r}
# MA plot
# MAplot(brca_data) #each array against a pseudo-median of all other arrays
```

![](C:/Users/MARINA/Documents/MASTER/TFM/Initial_analysis/MA_image_17.jpg)

In this MA plot, we are comparing the sample 17 with the reference, and we are measuring the differences in the intensity of the probes. As the red line is above the blue, that means that this sample has higher intensity than the median. The other plots can be found in the Supplementary section. 

```{r,fig.keep='first',message=FALSE}
# ----- RLE plots --------
library(affyPLM)
fitmodel<-fitPLM(brca_data) #fit a model
RLE(fitmodel,las=3,cex.axis=0.3,col=colors)
```

Again, we study the probes while comparing them to the other probes in the rest of the arrays. We compute the expression of one probe and compare to the expression media of the same probes in the other arrays. Once we have fit the model, the RLE plot is generated and all the medians are close to 0, that is what we expect.

```{r,fig.keep='first'}
# ------- NUSE plots -----------
NUSE(fitmodel,las=3,cex.axis=0.3,col=colors,ylim=c(0.95,1.1))
```

We also study the Normalized Unscaled Standard Errors (NUSE plots), in which we expect to see the median close to 1 for all the samples. There is a little bit of dispersion, but all the samples are really close to 1. 

In conclusion, there is a good quality of the samples and no array is removed from the study. 


# Normalization

After the quality control, we need to perform a normalization step, applying the Robust Multichip Average (RMA) approach.

```{r, message=FALSE}
# Normalization
brca.rma <- affy::rma(brca_data)#Normalization
dim(brca.rma)
```
After normalization we have 54675 summarized probesets. 

```{r}
# Boxplot of intensities
boxplot(exprs(brca.rma),las=3,cex.axis=0.3,outline=FALSE) 
abline(h=median(exprs(brca.rma)),col="blue")
```

The boxplot on the normalized intensities is performed and the distribution is similar and homogeneous in all of the samples.

# Sample aggregation

To see how samples aggregate, hierarchical clustering and PCA is performed. The purpose is to see if samples aggregate by their condition, or they don't. 
We will see if samples aggregate by disease (Cancer affected versus healthy), and by phenotype (BRCA1.AF/BRCA1.SA/BRCA2.AF/BRCA2.SA/NOMUT.SA/NOMUT/AF).

```{r,warning=FALSE,message=FALSE}
library(dendextend)

# SUbset no radiated samples
noradiated<-rownames(pdata[pdata$Treatment=='NOR',])

# Subset radiated samples
radiated<-rownames(pdata[pdata$Treatment=='RAD',])

brca.rma.norad<-brca.rma[,noradiated]
brca.rma.rad<-brca.rma[,radiated]

# --- Get matrix of intensities ---
expression<-exprs(brca.rma.norad)
```

We will use different methods to check if the clusterization is the same or similar.

## Sample aggregation by disease

```{r}
## --- Euclidean distance,method ward.D2 ---
hcwd2_all <- hclust(dist(t(expression)),method="ward.D2")

# Build dendrogram object from hclust results
dend_wd2_all <- as.dendrogram(hcwd2_all)
order_wd2_all<-unlist(dend_wd2_all)

## sample aggregation by disease
condition<-c(pData(brca.rma.norad)$Disease)
condition<-condition[order_wd2_all] 
#Rename AF and SA names
condition2 <- ifelse(condition == "AF", "Affected", 
                           ifelse(condition == "SA", "Healthy", condition))

colors<-palette('Dark2') # set a color palette
names(colors)<-levels(factor(condition2))
condition_colors <- colors[condition2]

dend_wd2_all %>% set("labels_col", condition_colors) %>% 
  set("labels_cex", 0.7) %>% # Change size
  plot(main = "Dendrogram of disease status")
legend("topright", legend = unique(condition2),fill = colors)


## --- Correlation based distance, average method ---
clust.cor.average_all<- hclust(as.dist(1-cor(expression)),method="average")
dendcbd_all<-as.dendrogram(clust.cor.average_all)
order_cbd_all<-unlist(dendcbd_all)
condition<-c(pData(brca.rma.norad)$Disease)
condition<-condition[order_cbd_all]
condition<-relevel(factor(condition),'SA')

#Rename AF and SA names
condition2 <- ifelse(condition == "AF", "Affected", 
                           ifelse(condition == "SA", "Healthy", condition))

condition_colors2 <- colors[as.numeric(factor(condition2))]

dendcbd_all %>% set("labels_col", condition_colors2) %>% # change color
  set("labels_cex", 0.7) %>% # Change size
  plot(main = "Dendrogram of disease status") # plot
legend("topright", legend = unique(condition2),fill = colors)
```

Samples do not aggregate well by disease condition.

## Sample aggregation by phenotype

```{r}
# --- Euclidean distance, method ward.D2 ---
hcwd2_all <- hclust(dist(t(expression)),method="ward.D2")
dendwd2_all <- as.dendrogram(hcwd2_all)
orderwd2_all<-unlist(dendwd2_all)

condition<-c(pData(brca.rma.norad)$Phenotype)
condition<-condition[orderwd2_all]

#Rename Affected and Healthy 
condition<-gsub('AF','AFFECTED',condition) 
condition<-gsub('SA','HEALTHY',condition)
condition<-factor(condition,c('BRCA1.AFFECTED','BRCA2.AFFECTED','BRCA2.HEALTHY','NOMUT.AFFECTED','NOMUT.HEALTHY','BRCA1.HEALTHY'))
colors2<-c('royalblue','yellowgreen','darkgreen','salmon','sienna','turquoise')
condition_colors <- colors2[as.numeric(factor(condition))]

# PLOT 

par(mar = c(5, 4, 4, 6),                                  # Specify par parameters
    xpd = TRUE)

dendwd2_all %>% set("labels_col", condition_colors) %>% # change color
  set("labels_cex", 0.9) %>% # Change size
  plot(main = "Dendrogram") # plot
legend("topright", inset = c(- 0.225, 0), legend = unique(condition), fill = colors2,cex = 0.8)

```

No aggregation of samples based on their phenotype condition. 

## PCA

As there is a very large number of variables (probe sets), we will use the principal component analysis (PCA) to reduce the dimensionality of the data.

```{r}
summary(pca.filt <- prcomp(t(expression), scale=T ))
```

The first principal component explains just 12,2% of the variability of the data, the second PC, around 9,3%, and the third PC 6,6%, which is very few variability. 

```{r,message=FALSE}
# --- PCA by phenotype ---
library(factoextra)
phenotype<-pData(brca.rma.norad)$Phenotype
phenotype<-gsub('AF','AFFECTED',phenotype)
phenotype<-gsub('SA','HEALTHY',phenotype)

fviz_pca_ind(pca.filt,col.ind =phenotype,addEllipses = TRUE,geom.ind = 'point',palette = c("royalblue", "turquoise", "yellowgreen",'darkgreen','salmon','sienna'))+labs(title = '                     B) Principal Component Analysis (PCA) ')

 
# ---PCA by disease ---
fviz_pca_ind(pca.filt,col.ind = pData(brca.rma.norad)$Disease,addEllipses = TRUE,geom.ind = 'point')
```

With the first two PC around 21,5% of the variability of the data is explained, which is very low. The ellipses overlap each other, which implies similar gene expression profiles between each condition. To sum up this part, after performing hierarchical clustering and PCA, there is no good aggregation of the samples, and there is not a specific gene profile for each condition. 

# Annotation 

In this step, we will assign the identifiers to known annotations. To do this, we will need the corresponding R annotation package to the microarray technology that was used. This R package corresponds to the Affymetrix HG-U133_Plus_2 Array annotation data (chip hgu133plus2). The version of this package is the 3.13.0.

As there are different probe sets in a microarray that correpond to the same gene, we will use the probe ID plus the gene symbol as the row name of the expression matrix, by now. There might be the presence of Not Available (NA) annotations for certain probe sets, and these probes will be removed from the experiment. 


```{r,message=FALSE}
library(annotate)
library(hgu133plus2.db)

# --- Annotation ---
data<-rownames(exprs(brca.rma))
symbol_data <-mget(data, env = hgu133plus2SYMBOL)

annotated_data<-paste(data,symbol_data,sep = '_')
rownames(brca.rma)<-annotated_data


# --- Remove NA in the annotation ---
expression_brca<-exprs(brca.rma)
pos_all_NA<-grep('_NA$',rownames(expression_brca))
brca.rma_noNA<-brca.rma[-pos_all_NA,]

dim(brca.rma)
dim(brca.rma_noNA) # remove 11574 NA
length(pos_all_NA)

```

We can see that when using this R package, there are 11574 probes sets that are not annotated (NA). In order to reduce the number of NA, and to try to get the maximum information as possible, we will use the annotation file provided by the microarray manufacturer, which is Thermo Fisher. This annotation file contains information for every probe set, such as the gene symbol and we will check whether the NA are indeed NA in the Thermo fhisher file or if we get some annotated genes for those non annotated probe sets using the R package. 


## Check NA probe sets

```{r,message==FALSE}
library(dplyr)
library(readr)
HG_U133_Plus_2_na36_annot <- read_csv("HG-U133_Plus_2.na36.annot.csv", skip = 25)
head(HG_U133_Plus_2_na36_annot)[1:5,c(1,14:17)]

# Get NA annotated probe names (of hgu133plus2.db R package)
NA_values<-grep('_NA$',rownames(expression_brca),value=TRUE)# probe set names of the no annotated 
NA_values<-gsub('_NA','',NA_values)

#select the gene names in the thermo-fisher annotation file of the R package NA values: 
pos_NA<-which(HG_U133_Plus_2_na36_annot$`Probe Set ID` %in% NA_values)
HG_na<-HG_U133_Plus_2_na36_annot[pos_NA,]

#Select only the columns Probe set ID and the Gene symbol
HG_gene_symbol_NA<-as.data.frame(HG_na[,c("Probe Set ID", "Gene Symbol")])

head(NA_values)# probe set names of the no annotated with R package 
head(HG_gene_symbol_NA) # Probe set ID + gene symbol of only those probe sets that were no annotated previously
```


This data frame contains the probe sets and the gene symbol of the thermo fisher file that were not annotated using the R package. As it is seen there are some probes that keep with no annotation (---), and others that have indeed an annotation.

```{r}
#need to order the HG data frame based on the order of the NA_values order
index <- match(NA_values, HG_gene_symbol_NA$`Probe Set ID`)
HG_gene_symbol_NA_ordered <- HG_gene_symbol_NA[index, ]

identical(NA_values,HG_gene_symbol_NA_ordered$`Probe Set ID`)

# Probe sets that are not annotated neither using R package and the thermo fisher file
dim(HG_gene_symbol_NA_ordered[HG_gene_symbol_NA_ordered$`Gene Symbol`=='---',])

# Probe sets that are being annotated when using the thermo fisher file and were not annotated with the R package
HG_gene_name_ofNAexpressionset<-HG_gene_symbol_NA_ordered[HG_gene_symbol_NA_ordered$`Gene Symbol`!='---',]
dim(HG_gene_name_ofNAexpressionset)
head(HG_gene_name_ofNAexpressionset)
#2184 probe sets with annotation that have to be substituted in the expressionSet object
```

Of the 11574 no annotated probes using the R package 'hgu133plus2.db', there are 9390 probe sets that will remain no annotated, whereas 2184 probe sets have an annotation. 

In microarrays, a probe set can have more than one annotated gene associated with it, as it seen in the above table. Since each probe set contains multiple individual probes with varying sequences, they can target a region that is shared by some genes or transcripts isoforms. This occurs when there are regions of sequence similarity or overlap among different genes, so, the probe set can hybridize with multiple transcripts or genes. 

To deal with this, we will get the first gene symbol identification for those probes that have multiple gene symbols annotated. 
```{r}
# ----  Get the first Gene Symbol ----
# Create an empty vector to store the first values
split_values <- character(length(HG_gene_name_ofNAexpressionset$`Gene Symbol`))
for (i in 1:nrow(HG_gene_name_ofNAexpressionset)){
  split_values[i] <- strsplit(HG_gene_name_ofNAexpressionset$`Gene Symbol`, " /// ")[[i]][1]
  }

HG_gene_name_ofNAexpressionset$Unique_Gene_symbol<-unlist(split_values)
```

Once we have a unique gene symbol for each probe set, we have to substitute them for the NA symbol in the expression matrix.

```{r}
# Get the gene names and substitute them instead of NA
change_NA_values<-intersect(NA_values,HG_gene_name_ofNAexpressionset$`Probe Set ID`)
new_probesets_anotated<-paste(change_NA_values,HG_gene_name_ofNAexpressionset$Unique_Gene_symbol,sep = '_')

pos_inthematrix_that_need_tobechange<-which(data %in% change_NA_values)

#Subset the expression matrix of those probe sets its name has to be changed
matrix_subset <- as.matrix(expression_brca[pos_inthematrix_that_need_tobechange, ])#this contains the intensity values of the probes sets that its gene symbol has been change
rownames(matrix_subset) <- new_probesets_anotated

expression_brca[pos_inthematrix_that_need_tobechange,][1:5,1:5]
head(matrix_subset)[1:5,1:5]
```

We can see that the probe set names that were annotated in the thermo fisher file and didn't in the R package, have been changed. 

Now, we want to know how many probe sets are annotated in both R package and Thermo fisher file.

```{r}
# Get the probe sets that were annotated using the R package.
probsets_well_annotated_R_pack<-rownames(exprs(brca.rma_noNA))

# Split the vector into probe names and gene names using the last underscore
split_probesets <- strsplit(probsets_well_annotated_R_pack, "_(?!.*_)", perl = TRUE)

# Extract the probe set names and the gene names and create a data frame
probe_names<-NULL
gene_names<-NULL
for (i in 1:length(split_probesets)){
  probe_names[i]<-split_probesets[[i]][1]
  gene_names[i]<-split_probesets[[i]][2]
 }
df_annotated_probes_R_pack <- data.frame(ProbeName = probe_names, GeneName = gene_names)
head(df_annotated_probes_R_pack)

# To know the position of the probes that are annotated in both data frames.
x<-which(HG_U133_Plus_2_na36_annot$`Probe Set ID`%in%df_annotated_probes_R_pack$ProbeName)
df_TF<-HG_U133_Plus_2_na36_annot[x,c("Probe Set ID", "Gene Symbol")]

#Check the probe set names are in the same order than the df of thermo.fisher
identical(df_annotated_probes_R_pack$ProbeName,df_TF$`Probe Set ID`)

index <- match(df_annotated_probes_R_pack$ProbeName, df_TF$`Probe Set ID`)
df_TF_or <- df_TF[index, ]

identical(df_annotated_probes_R_pack$ProbeName,df_TF_or$`Probe Set ID`)

# How many of the annotated probes sets using the R package, are no annotated in the TF file
dim(df_TF_or[df_TF_or$`Gene Symbol`=='---',])
# There are 229 probe sets that were annotated using the R package and are not annotated in the TF file
dim(df_TF_or[df_TF_or$`Gene Symbol`!='---',])
# There are 42872 probe sets that were annotated using the R package, and keep being annotated in the TF file

```

There are 229 probe sets that were annotated when using the R package, and are no annotated in the thermo fisher file, and 42872 probe sets that are annotated in the R package and keep being annotated in the thermo fisher file. 
This results are summarized in the following confusion matrix.

```{r}
# --- Confusion matrix ---
confusion_matrix<-data.frame(Annotated_TF_file=c(dim(df_TF_or[df_TF_or$`Gene Symbol`!='---',])[1],dim(HG_gene_name_ofNAexpressionset)[1]               ),No_annotated_TF_file=c(dim(df_TF_or[df_TF_or$`Gene Symbol`=='---',])[1],dim(HG_gene_symbol_NA_ordered[HG_gene_symbol_NA_ordered$`Gene Symbol`=='---',])[1]),row.names = c('Annotated_R_package','No_annotated_R_package'))

confusion_matrix

```

It is important to check whether the probes that are annotated in both R package and in the thermo fisher file, have the same gene symbol. To do so, we will calculate the percentage of the gene symbols that are identical.  

```{r}
# Select the 42872 probe sets.
df_annotated2_TF<-df_TF_or[df_TF_or$`Gene Symbol`!='---',]
poss<-which(df_annotated_probes_R_pack$ProbeName %in% df_annotated2_TF$`Probe Set ID`)
df_annotated_probes_R2<-df_annotated_probes_R_pack[poss,]

# The probe sets need to be in the same order, otherwise, we will get a false percentage
identical(df_annotated2_TF$`Probe Set ID`,df_annotated_probes_R2$ProbeName)
rownames(df_annotated_probes_R2)<-1:nrow(df_annotated_probes_R2)

# Select the probe sets that have more than one gene symbol annotation, and continue with the first annotation.
pos_multiplegenes<-grep('///',df_annotated2_TF$`Gene Symbol`)
df_TF_multiplegenes<-df_annotated2_TF[pos_multiplegenes,]

split_values2 <- NULL
for (i in 1:nrow(df_TF_multiplegenes)){
  split_values2[i] <- strsplit(df_TF_multiplegenes$`Gene Symbol`, " /// ")[[i]][1]
  }
df_TF_multiplegenes$Unique_Gene_symbol<-unlist(split_values2)

# Create a data frame with the probe name and with only one Gene symbol annotation.
merged_df <- merge(df_annotated2_TF, df_TF_multiplegenes, by = "Probe Set ID", all.x = TRUE)
merged_df<-merged_df[,-3]
# Update the Gene column with the values from the second data frame
merged_df$Gene <- ifelse(is.na(merged_df$Unique_Gene_symbol), merged_df$`Gene Symbol.x`, merged_df$Unique_Gene_symbol)
merged_df <- merged_df[, c("Probe Set ID", "Gene")]

# Find the number of matching names in the same position
identical(df_annotated_probes_R2$ProbeName,merged_df$`Probe Set ID`) #make sure every ID is the same in both df
sum(df_annotated_probes_R2$GeneName==merged_df$Gene)/length(merged_df$Gene)*100

```

There are 42872 probe sets that are annotated in both ways, using the R package and the annotation file. From this probe sets, 92,79% have exactly the same Gene Symbol. 3090 probe sets have a different annotated gene name, but that doesn't mean that the gene is different. As we can see next, there are some probe sets that refer to the same gene, but the Gene Symbol is the previous used or a synonymous. It can may happen that, for a probe set, more than one possible gene is identified. In this analysis we keep with the first annotated gene, but maybe the R package is selecting the second of the TF file.

```{r}
#How many probe ID are differently annotated
sum(df_annotated_probes_R2$GeneName!=merged_df$Gene)

# Example of probe sets with different Gene
grep('1558480_at',merged_df$`Probe Set ID`)
df_annotated_probes_R2[3536,]
merged_df[3536,]

df_annotated_probes_R2[6707,]
merged_df[6707,]
  
```

For example, the probe set 1558480_at in the R hgu133plus2.db package is annotated as TMCC1-DT. However, in the Thermo fisher annotation file, is as TMCC1-AS1. As it indicates the HUGO Gene Nomenclature Committee (HGNC), the approved symbol is TMCC1-DT, but the previous one was TMCC1-AS1. The same occurs with the probe set 1569973_at. The approved symbol is SEPTIN7P2 and the previous one was SEPT7P2. So, both annotation methods make reference to the same gene, although the name is different and this affects the percentage of same gene symbols between the annotated probe sets in R and in the Thermo fisher. In conclusion, the percentage of gene symbols shared by the R hgu133plus2.db package and the Thermo fisher file, is indeed higher than 92,72%. 


Let's check whether the genomic position of the 229 non-annotated probes using the thermo fisher file that were annotated using R, corresponds to the gene that is annotated. We will use the UCSC Genome browser on Human, version GRCh37/hg19. 

```{r,warning=FALSE}
# Select the probes annotated in R but not in the Thermo fisher file.
TF_no_annotated_yesR<-df_TF_or[df_TF_or$`Gene Symbol`=='---',]
probes_id<-TF_no_annotated_yesR$`Probe Set ID`
rownames(HG_U133_Plus_2_na36_annot)<-HG_U133_Plus_2_na36_annot$`Probe Set ID`
head(HG_U133_Plus_2_na36_annot[probes_id,c(1,13:16)])

rownames(df_annotated_probes_R_pack)<-df_annotated_probes_R_pack$ProbeName
head(df_annotated_probes_R_pack[probes_id,])

```


So, the genomic location of the probe sets is in the annotation file. We will select the the coordinates for each probe, search them in the USCS genome browser, and compare if the gene is the same that annotated using the R package. 

For the first probe, 1552976_at, the genomic coordinates correspond to the gene DNAJB13, which is the same that was annotated. 

![](C:/Users/MARINA/Documents/MASTER/TFM/Data_analysis/1552976_at.jpg)



For the probe 1554194_at, we can see that the genomic coordinates corresponds to C8orf58 gene, and the gene annotated in the R package is a LOC. In this case, the gene do not match. 
![](C:/Users/MARINA/Documents/MASTER/TFM/Data_analysis/1554194_at.jpg)


After analyzing and comparing the annotations by the two different approaches, we decide to keep with the downstream analysisi with those probes sets annotated by the Thermo Fisher file. Since the annotation file is provided by the microarray manufacturer, it is considered an official, curated and reliable source of information, ensuring accuracy. On the other hand, the R package for probe annotations is typically maintained by researchers or bioinformatics, which are more versatile. 

In conclusion, we will keep the analysis with the probe sets that were annotated using the Thermo fisher annotation file. In total, we retrieve 45056 probe sets. 

```{r}
annotated_probes_TF<-HG_U133_Plus_2_na36_annot[HG_U133_Plus_2_na36_annot$`Gene Symbol`!='---',]
annotated_probes_TF2<-annotated_probes_TF[,c("Probe Set ID", "Gene Symbol")]

# Select the probe sets that have more than one gene symbol annotation, and continue with the first annotation.
pos_multiplegenes<-grep('///',annotated_probes_TF2$`Gene Symbol`)
df_TF_multiplegenes<-annotated_probes_TF2[pos_multiplegenes,]

split_values2 <- NULL
for (i in 1:nrow(df_TF_multiplegenes)){
  split_values2[i] <- strsplit(df_TF_multiplegenes$`Gene Symbol`, " /// ")[[i]][1]
  }
df_TF_multiplegenes$Unique_Gene_symbol<-unlist(split_values2)

# Create a data frame with the probe name and with only one Gene symbol annotation.
merged_df <- merge(annotated_probes_TF2, df_TF_multiplegenes, by = "Probe Set ID", all.x = TRUE)
merged_df<-merged_df[,-3]
# Update the Gene column with the values from the second data frame
merged_df$Gene <- ifelse(is.na(merged_df$Unique_Gene_symbol), merged_df$`Gene Symbol.x`, merged_df$Unique_Gene_symbol)
merged_df <- merged_df[, c("Probe Set ID", "Gene")]


pos_probes_expressionmatrix<-which(data %in% merged_df$`Probe Set ID`)
final_expression_matrix <- as.matrix(expression_brca[pos_probes_expressionmatrix, ])

# We need to change the rownames for the probe names of the Thermo fisher file
new_probesets_<-paste(merged_df$`Probe Set ID`,merged_df$Gene,sep = '_')
rownames(final_expression_matrix)<-new_probesets_

dim(final_expression_matrix)

```


## Remove duplicated probe set genes

It is frequent that different probe sets correspond to the same gene. Once the probe sets are annotated, we have to remove duplicated genes. Otherwise, the analysis can lead to biased and inaccurate results. 

The implemented function, will select the expression values of the duplicated genes, and will compute the mean value for each individual. It will return a list containing each repeated gene, and the mean expression values for each sample. Finally, we will create a matrix, that contains the expression values of both unique and previous duplicated genes. 

```{r}
# --- REMOVE DUPLICATED ----

symbols<-merged_df$Gene

# ----- FUNCTION ----

find_repeated_genes <- function(vector, matrix) {
  # Find repeated gene names
  repeated_names <- names(table(vector))[table(vector) > 1]
  
  # Initialize a list to store the mean values
  repeated_means <- list()
  
  # Iterate over each repeated gene
  for (gene_name in repeated_names) {
    # Find the positions of the repeated gene in the vector
    positions <- which(vector == gene_name)
    
    # Find the rows in the matrix that correspond to the positions
    rows <- matrix[positions, , drop = FALSE]
    
    # Calculate the mean by column for the rows
    means <- colMeans(rows)
    
    # Store the means in the list
    repeated_means[[gene_name]] <- means
  }
  
  # Return the list of mean values for each repeated gene
  return(repeated_means)
}

# Call the function to find the rows of the repeated genes in the matrix
result <- find_repeated_genes(symbols, final_expression_matrix)

# Extract the gene names
gene_names <- names(result)

# Create a matrix with row names for genes and columns for samples
mat <- matrix(unlist(result), nrow = length(gene_names), byrow = TRUE)

# Add row names to the matrix
rownames(mat) <- gene_names
colnames(mat) <- colnames(exprs(brca.rma))

dim(mat)


# --- Get unique genes ---

# Create a table of gene counts
gene_counts <- table(symbols)

# Extract the genes that occur only once
unique_genes <- names(gene_counts[gene_counts == 1])

#Extract the position of the unique genes.
unique_gene_pos<-match(unique_genes,symbols)

# Search in the matrix, the position of the unique genes 
matrix_unique_genes<-final_expression_matrix[unique_gene_pos,]
rownames(matrix_unique_genes)<-gsub("^.*_", "",rownames(matrix_unique_genes))

# Join the two matrices
final_matrix<-rbind(matrix_unique_genes,mat)
brca.noduplicated<-final_matrix[order(rownames(final_matrix)),]
dim(brca.noduplicated)

# We need to transform the matrix object brca.noduplicated to an ExpressionSet
library(Biobase)
brca.noduplicated<-ExpressionSet(assayData = brca.noduplicated)
pData(brca.noduplicated)<-pdata
```

After removing the duplicated genes, we end up with a matrix that contains the expression levels of 21923 genes. 